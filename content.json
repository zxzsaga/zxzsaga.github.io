{"pages":[{"title":"About","text":"爱好： Game Dev Game Design Game Engineering Game RTS Action Game RPG STG Soccer Milan MU Liverpool 邮箱：zxzsaga@gmail.com","link":"/about/index.html"}],"posts":[{"title":"生日礼物：《只狼：影逝二度》","text":"今天是我28岁的生日，也是《只狼：影逝二度》的发售日。","link":"/2019/03/22/Sekiro-Release/"},{"title":"SubsetGames","text":"Subset Games 是由 Justin Ma 和 Matthew Davis 两人在2011年创办的游戏工作室。在此后的几年里，他们制作了著名游戏 FTL: Faster Than Light 和 Into the Breach. 他们在 Youtube 上有几场演讲： FTL Postmortem: Designing Without a Pitch(2016年4月28日) [2018 TGDF] Justin Ma ─《FTL》與《Into the Breach》的設計經驗談(2018年11月13日) Into the Breach Design Postmortem(2019年4月30日) 除此之外还有几场没有这么正式的。 从 Justin Ma 的 LinkedIn 可以看到，他是2007年毕业的，在2011年4月成立了 Subset Games 开始做自己的游戏，然后一直工作至今。 也就是说他在工作4年之后开始创业，第一个项目就成了爆款。","link":"/2019/12/20/SubsetGames/"},{"title":"樱井政博","text":"","link":"/2020/03/03/Sakurai-Masahiro/"},{"title":"C# 静态变量初始化顺序的一个问题","text":"今天在写 C# 的时候遇到下面这样一个问题。 首先我们大多数人知道，如果有一个静态类像这样： 12345public static class c1{ public static int v1 = 256; public static int v2 = v1;} 然后打印 v2 会得到 256。 而如果它是： 12345public static class c1{ public static int v2 = v1; public static int v1 = 256;} 然后打印 v2 会得到 0。 这是由它声明顺序决定的。 但是如果静态成员变量 v1, v2 在不同的类中，情况就没有这么简单。如果有这么两个类： 123456789public static class c1{ public static int v1 = 256;}public static class c2{ public static int v2 = c1.v1;} 此时不管是以上面这样的顺序声明两个类，还是换一下顺序： 123456789public static class c2{ public static int v2 = c1.v1;}public static class c1{ public static int v1 = 256;} 打印 c2.v2 的结果都是 256。 这时我就纳闷了，就跟朋友们讨论了一下，他们说可能是因为编译器很智能，会根据类之间的依赖关系来决定初始化顺序。那么就有新的问题了，如果他们相互依赖的话，情况又是怎么样呢？ 为了测试，把两个类改成这样： 1234567891011public static class c1{ public static int v1 = 256; public static int v2 = c2.v1;}public static class c2{ public static int v1 = 1024; public static int v2 = c1.v1;} 此时先后打印 c1.v2, c2.v2, 会得到结果： 121024 // c1.v20 // c2.v2 即使我调换了 c1, c2 的声明顺序，也是得到这个结果。 但是，如果我换一下打印顺序，先打印 c2.v2, 再打印 c1.v2, 结果是： 12256 // c2.v20 // c1.v2 也就是说，在这种情况下，会根据代码的执行顺序来决定初始化顺序。不会报错，也不会报警告。 而这通常不是我们想要的。在编码过程中要尽量避免把代码写成这种情况，我们不应该依赖智能的编译器。","link":"/2020/02/28/C-Sharp-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/"},{"title":"瓦里欧制造系列","text":"瓦力欧制造是由任天堂发行的电子游戏系列。由任天堂企划开发部与 Intelligent Systems 开发，任天堂发行。该游戏的口号为“最多 最短 最快”，特点是每部作品包含了多个小游戏，大部分小游戏可以在5秒钟之内完成，而“魔头关”需要较长的时间完成。 游戏名称 发行日期 发售平台 《瓦力欧制造》 2003年3月21日 Game Boy Advance 《集合!!瓦力欧制造》 2003年10月17日 任天堂GameCube 《转转瓦力欧制造》 2004年10月14日 Game Boy Advance 《摸摸瓦力欧制造》 2004年12月2日 任天堂DS 《手舞足蹈瓦力欧制造》 2006年12月2日 Wii 《照照瓦力欧制造》 2008年12月24日 任天堂DSi（DSiWare） 《老子制造》 2009年4月29日 任天堂DS 《玩玩老子制造》 2009年4月29日 Wii（WiiWare） 《瓦里奥游戏》 2013年3月28日 Wii U 《瓦力欧制造 豪华版》 2018年7月27日 任天堂3DS 《瓦力欧制造 豪华版》 集合了首三作的操作方式的大集合作品。瞬间小游戏为收录了过往作品的精选外加新作品，合共超过300个。 下面是《瓦力欧制造 豪华版》的所有小游戏：","link":"/2020/03/12/%E7%93%A6%E9%87%8C%E6%AC%A7%E5%88%B6%E9%80%A0%E7%B3%BB%E5%88%97/"},{"title":"Skywind Inside Review","text":"最近关注了一位大牛韦易笑，把他到目前为止的博文大致浏览了一下。我比较感兴趣的内容主要是关于 游戏开发随笔 和 网络游戏技术 两部分的。今天记录一下看了他一些 游戏开发随笔 后的感悟。 这方面的文章有三篇： 现实主义题材需要拯救（2007） 你为什么会离开游戏行业？（2015） 二十年前是怎样开发游戏的？（2015） 现实主义题材需要拯救首先他谈到的是参考游戏 vs 参考生活。做游戏不应该只参考游戏，而应该参考生活，因为艺术源于生活。现在很多人忘了这点，所以做不出创新。游戏只是一个载体，就像小说、电影一样。它所承载的内容才是更重要的。如果只关心做游戏的技术，而不注重观察生活，可能在“术”上能做到很高的水准，但却做不到“艺”上的合格，从而做不出游戏的作品。所以做游戏的不应该住关注游戏领域，而应该关注生活的方方面面，创意往往来源于这些地方，Overcooked 就是很好的例子。 其次谈到了创新 vs 改良。 人类既是依赖习惯的动物，也是追求新鲜感的动物。 好的游戏应该平衡这两点，类似的观点在开发者：独立游戏的十个成功秘诀（以及为什么它们不存在）一文中也有所谈到。熟悉感能让玩家将作品与之前的美好记忆联系起来，并被它吸引；新颖性为玩家带来令人兴奋的新鲜感受。做的游戏不应该太老套，也不应该太过新颖让人难以理解。 下面一个重要的话题是现代题材 vs 古典题材。我们背负了五千年文化的大包袱，很少有关于现代题材的优秀游戏。大厂不愿意做现代题材，只有某些个人的灵光乍现，才会产生一些现代题材游戏，像潜伏之赤途/隐形守护者的优秀游戏太少了，而且始终不是主流。 我一直认为把武侠的精神代入现代题材有着很好的意义，武侠是一种精神，而不是功夫。目前看来，相对于国内的研发水平，做这样的游戏太过冒险、太过宏大了，不过我相信以后会有这样的作品的， 现实主义题材需要拯救这篇文章作于2007年，现在已经2019年，文中所提到的问题依旧没有得到解决。大牛能在那个时候就有这些想法也不容易，而十几年过去了在这些方面一点儿进步也没有也是难得…… 不过挺好的，有问题才有机会，不然我们这些人干嘛呢？ 二十年前是怎样开发游戏的？啊，大概就是说20年开发游戏巨麻烦，什么都要自己实现，还没有资料查。励志的是最后两段： 行业总是要发展的，我也从《编程技巧与维护》《VGA显示原理》。。。和各种杂志上获取了不少知识，当年写这些文章的人，和身边搞计算机的，都比我大很多，我幼小的心灵里总有一份冲动，冥冥之中觉得将来自己肯定能超过他们，这不是因为我看不起她们，异或我狂妄自大，而是只有这样，站在她们肩上，才能对得起大家共同爱好的这个行业，大家共同追求的事业。 而今天，我会尽量利用业余时间，于各处培训游戏开发，帮助大家该如何实现各种东西，目的也只有一个，让今天的小孩将来有一天能够超过我，不是因为她们狂妄自大，异或我妄自菲薄，而是因为只有这样，让她们站在我的肩上，才能对得起大家共同爱好的这个行业，大家共同追求的这个事业。 太励志了（摇了摇头，自叹不如）。 你为什么会离开游戏行业？ 游戏产品成功率只有1%，做游戏成败犹如开宝箱。 做游戏不可持续发展，做游戏不如做应用。 开发团队失去主导。 游戏开发成本持续上升，创业越来越难。 劣币驱逐良币。 大家都只关心钱，不关心游戏了。 这篇文章推荐去看原文你为什么会离开游戏行业？ 总结一句话就是：做游戏赚钱越来越难了。 文章最后给出一碗鸡汤解决方案：做精品游戏、拼质量。 大家只有重新找准产品方向，在内容和品质上实现新的突破，继续把行业门槛推高，提升玩家审美。把所谓的大学生都能做的垃圾游戏们送进坟墓，结束目前的混乱，让游戏将重新回到不是谁都能做的年代，用一款款优秀的作品告诉渠道和用户，什么才叫真正的游戏。苹果能在手机泛滥到处山寨化的日子里，重新找到突破。今年上半年上线的若干3A大作，任然能在同质化严重的手游市场脱颖而出，结束了自2013年上半年来渠道被无限放大的乱象。凭借的都不是宣传，更不是渠道，而是一颗颗不甘沉沦的心，和扎扎实实多年摸爬滚打积累的经验。 当然，只有这样，行业价值从渠道回归产品本身，才能让整个行业更理性健康。当然，也只有这样，用一个个的精品游戏，重新将项目变回事业，开发组才能找回昔日逝去的尊严。到那时，渠道当然偶尔也可以招聘一两个大学生，做些棋牌和跑酷娱乐下，但是，那叫做玩具，不能称其为 “游戏作品” 。 我以为只有年纪比较小的人才会中二呢，哈哈，看来作者是真的热爱这行，而且很乐观，这比这段话更容易鼓励人。 大牛的博客里还有这样一篇奇葩：比尔·云风传奇，貌似讲的是云风大牛。以前网易的大牛还真多啊。","link":"/2019/03/29/Skywind-Inside-Review/"},{"title":"花括号提不提行？","text":"以前写 JavaScript 的时候，主流的风格是花括号不提行： 1234function unlerp(a, b, t) { assert(b &gt; a); return (t - a) / (b - a);} 早期的时候 Unity 文档里使用 C# 时花括号也不提行。但是 C# 的主流风格是花括号要提行： 123456public static class LayerManager{ public static readonly int Player = LayerMask.NameToLayer(&quot;Player&quot;); public static readonly LayerMask PlayerMask = 1 &lt;&lt; Player;} 由于我有时写 JavaScript，有时写 C#, 所以就干脆都不提行了，统一风格。于是我写 C# 就会像是这样： 12345678910public void TogglePlacingState() { bool shouldSettingPosition = !IsPlacing; if (shouldSettingPosition) { ghostObject.SetActive(true); StartUpdatePosition(); } else { StopUpdatePosition(); ghostObject.SetActive(false); }} 但是现在越来越多的人写 C# 时花括号要提行了。我自己虽然喜欢不提行，但总是需要跟别人合作的，还是有必要改变一下： 123456public static class LayerManager{ public static readonly int Player = LayerMask.NameToLayer(&quot;Player&quot;); public static readonly LayerMask PlayerMask = 1 &lt;&lt; Player;} 其实花括号只是一个例子，其他一些代码风格也可能有所不同。例如 JavaScript 的函数名流行小驼峰命名法，而 C# 流行大驼峰命名法。 不同的编程语言有不同的语言特性和代码风格，即使需要同时使用多种编程语言，也不应该使用自己最习惯的同一种风格，而应该入乡随俗地根据各自语言的 style guide 来进行编码，而这也没有想象中那么麻烦。","link":"/2020/03/19/%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%8F%90%E4%B8%8D%E6%8F%90%E8%A1%8C%EF%BC%9F/"},{"title":"《极乐迪斯科》中文化","text":"前天早上起床在微博上看到《极乐迪斯科》推出中文版： 今天又看了他们自己在知乎的回答：如何评价游戏 Disco Elysium（极乐迪斯科）？ - ZAUM的回答 - 知乎 Steam 还打折，87元。 赶紧下单支持一下。","link":"/2020/03/21/%E3%80%8A%E6%9E%81%E4%B9%90%E8%BF%AA%E6%96%AF%E7%A7%91%E3%80%8B%E4%B8%AD%E6%96%87%E5%8C%96/"},{"title":"《魔兽争霸3》中的维修费用","text":"最近 Youtube 推荐了一些魔兽争霸3比赛的视频给我，我也打开看了几场。打法比以前多了一些变化，但是整体的节奏还是跟以前差不多。我一直对维修费用这一设计有所抱怨，认为它限制了玩家出兵，从而影响了战斗规模。 以往 RTS 的一个特性是，部队规模基本上与时间流逝成正比。前期只有几个单位，经过发展运营，后期大量部队的交战，形成一定的史诗感。而魔兽的维修费用设计，让部队规模对经济产出形成了负反馈，限制了大部队成型。 比较常见的两个支持这一设计的说法是： 这样可以让玩家更具侵略性，而不是在家憋大部队。 这样可以让英雄在战斗中占据更重要的地位。 第一点我认为为是完全站不住脚的。星际争霸没有维修费用，有着更高的人口上限，这没有导致玩家更憋。选手有着很高的游玩乐趣，比赛也极具观赏性。 而第二点的逻辑是相对说得通的。但是我依旧认为，即使是为了让英雄有更重要的地位，也有别的方法来促进这一点。这其实就是一个英雄能力与部队规模之间的平衡问题。设计师担心部队规模的扩大会削弱英雄在战斗中的重要性，于是限制了部队规模扩大。但为了解决这个问题，我认为有其他更好的选择，比如通过一定的手段来提升英雄的成长性。像类似调整英雄升级经验、增强技能成长、增强道具这些手段都是可以的。 魔兽比赛的现状是：一场比赛中，大部分时间人口控制在50以内；大部分比赛里，整场比赛人口都不会超过80。 而如果能做到，随着比赛时间流逝，英雄在成长，部队规模也在扩大，最后形成史诗级战斗，有什么不好呢？ 然后我找到了一篇文章《魔兽争霸 3：重制版》开发者专访：与原版有哪些不同？里，一个开发者（主技美）是这么解释的： Q: 既然你们都参与过原作的项目，那当初有没有一些你们希望能做更好却没实现的内容呢？现在重制了，有没有机会把十几年前没做到的事做得更好呢？ McNaughton: 那我举个例子吧。《魔兽争霸 3》是我们制作的第一款 3D 游戏，而当时的电脑性能实在差，我们能利用的内存很有限，游戏表现也很成问题。所以我们提出了维护费用这个机制，玩过《魔兽争霸 3》的玩家肯定都知道。维护费用会让玩家有意限制自己的单位数量。当然要是当时没有这些硬件限制，那我们也就不会加入维护费用机制了。但也正是因为这些限制，我们才能制作出以英雄为核心，RPG 元素更加丰富的游戏，这也成了《魔兽争霸 3》的标志。由此可见，维护费用还是有历史意义的，所以《重制版》中我们保留了这个机制。 哦，原来是这样……","link":"/2020/03/25/%E3%80%8A%E9%AD%94%E5%85%BD%E4%BA%89%E9%9C%B83%E3%80%8B%E4%B8%AD%E7%9A%84%E7%BB%B4%E4%BF%AE%E8%B4%B9%E7%94%A8/"},{"title":"不再使用 TypeScript","text":"它就是个怎么看都很奇怪的，基本上没有用处的，凭空让代码变 gay 的，没事找事的，让人幻想以为有用的安慰剂。","link":"/2020/03/26/%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8-TypeScript/"},{"title":"数据表在工程中的地位","text":"游戏制作过程中难免会涉及到使用一些数据表。 很多游戏对数据表的使用方法是 用游戏对象去依赖数据表，比如初始化血量、攻击力等数值时，去根据相关表格进行计算。 但我个人更倾向于使用 数据表依赖游戏对象 的方法，游戏对象完全不依赖数据表的存在。具体的做法是：数据表中的数据读写，实际上是对游戏对象数据的读写，数据表只是相当于把多个游戏对象的数值汇总，以用于统一管理。 在 Unity 里我习惯使用 ScriptableObject 来作为数据表，这样的话引用 prefab 会很方便。给数据表的 property 加上 Odin Inspector 的 ShowInInspector, 就可以实现通过 ScriptableObject 对 prefab 进行读写。 Prefab 是可以这样做了，但是由于场景中的对象无法在 ScriptableObject 中序列化，所以对于场景对象的修改还得想想办法。 我目前的办法是在场景中放一个对象 M, 用于存放场景中所有需要通过数据表进行修改的对象引用。每次使用数据表时，把 M 拖到数据表中进行数据表中引用的初始化，这样就可以了。 实际上大部分人大概都不是使用 ScriptableObject 来做数据表，而是使用例如 Excel, CSV 之类的表格。这些表格不能读取项目中游戏对象的实际参数，这时我认为应该使用 ScriptableObject 作为中介者，读取表格的数据，写入各个对象。 上面我所说的，都是针对游戏开发阶段。如果是 Stellaris 这类需要在发布后依赖外部表格的游戏，或者是玩家可以通过表格进行自定义修改的游戏，那么需要重新考虑问题。 大部人可能为认为做这些是多此一举，但我写工程习惯于简洁直接地表达事物之间的关系。在整个游戏逻辑里，数据表的概念实际上是不需要的，实际必要的是游戏对象的数值。数据表只是开发者开发时的中间产物，那么它就不应该出现在最后的发布版里。","link":"/2020/04/26/%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9C%B0%E4%BD%8D/"},{"title":"在极简的道路上越走越远","text":"最近一个项目开始使用极简的风格写代码，可省略的访问修饰符不写了，浮点数是整数的时候 f 也不写了（两个数相除的时候，前面一个写 f）。 同时尝试将相关的字段和属性写在一起，而不是像以前一样先写所有字段，再写所有属性。（跟极简没啥关系） 写笔记时，一段话的最后一个句号也不写了。 就是图个清爽。","link":"/2020/04/27/%E5%9C%A8%E6%9E%81%E7%AE%80%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A%E8%B6%8A%E8%B5%B0%E8%B6%8A%E8%BF%9C/"},{"title":"Animator Controller 与状态机","text":"前一阵子看到一个 Unity 教学 youtuber 在用状态机做角色控制的时候，竟然直接使用 Animator Controller （以下称为动画状态机）作为角色逻辑状态机，这是我从没想过也不敢尝试的方法。 我也喜欢用状态机来做角色控制，但一般是自己写一个逻辑状态机，然后再用这个状态机去确定动画播放。动画状态机对我来说只是一个播动画的组件，即使哪天 Unity 出了新的动画系统也可以随时把它换掉。 其实以前在做项目的时候，我曾对于动画状态机和自己写的逻辑状态机如何协同工作感到困惑。如果动画状态机也使用一些 conditions 来进行状态切换，那么动画状态机和逻辑状态机很可能会出现不一致的情况。这在做网络游戏的时候尤其明显，即便服务端和客户端同步了逻辑状态机，动画状态机的状态由于一些 timing 的差异也会不一致，除非再单独同步动画状态机，也就是逻辑状态和动画状态各自单独同步，但我觉得这个方案并不合适（也考虑过只有服务端使用动画状态机，客户端用类似 legacy 动画系统的方法来播放动画，也不好）。 后来得出的方案是一切以逻辑状态机为准，逻辑状态机决定动画播放，即使没有动画系统，逻辑状态机也能独立完成整个游戏逻辑。这样如果想要动画系统表现好，逻辑状态机应该知晓一些动画的数据信息，这些信息是在编辑器阶段（而非运行时阶段）就准备好的，比如逻辑状态机和动画系统都应该知晓攻击动画的持续时间是多久，而不互相依赖。为了网络同步，动画系统应该能从任意动画切换到任意动画，这样动画系统实际退化成了一个简单的动画播放器。 我想应该很多网络游戏都是这样做的。 但如果是一个单机动作游戏呢？如果逻辑高度依赖动画系统，尤其是一些近几年兴起的 physics based 动画系统呢？这时动画系统还是需要参与逻辑运算。而开头说的那位 youtuber 更激进了一步，直接将动画状态机作为逻辑状态机，以致于理论上来说，某些动画状态机节点甚至可能不播放动画。以前 StateMachineBehaviour 刚出的时候我以为只是用来做一些简单的动画计算，没想到现在可以用来运行核心逻辑。 我本来也不是很确定像他这样用会不会有什么问题，但后来看到 CinemachineStateDrivenCamera组件里，Unity 将 Animator Controller 作为不播放动画的纯状态机来使用，我想 Unity 是倾向于这样使用的。","link":"/2020/05/18/Animator-Controller-%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"title":"处理角色移动","text":"在 Unity 里做角色移动通常有两种方式： 设置 rigidbody.velocity 刚体速度，通过物理引擎进行位移。 设置 transform.position 来改变物体位置。 使用第1种方式通过刚体来运动的话，可以不用自行处理碰撞检测，但是对角色移动不容易做到精确控制。我倾向于使用第2种方式，直接修改 transform.position 来进行位移。这样的话，我们就需要处理碰撞检测的问题。 我目前采用的移动逻辑是这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[RequireComponent(typeof(CapsuleCollider))]class CharacterMove : MonoBehaviour{ float radius; float thickness = 0.05f; Vector3 localPoint1; Vector3 Point1 =&gt; transform.TransformPoint(localPoint1); Vector3 localPoint2; Vector3 Point2 =&gt; transform.TransformPoint(localPoint2); LayerMask layerMask; void Awake() { var capsuleCollider = GetComponent&lt;CapsuleCollider&gt;(); radius = capsuleCollider.radius; float halfHeight = capsuleCollider.height * 0.5f; localPoint1 = capsuleCollider.center + (halfHeight - radius) * Vector3.up; localPoint2 = capsuleCollider.center + (halfHeight - radius) * Vector3.down; layerMask = LayerManager.playerMoveCastMask; var state = GetComponent&lt;Animator&gt;().GetBehaviour&lt;Character_State_Wander&gt;(); state.SetCharacterMove(this); } public void Move(Vector3 direciton, float distance) { while (distance &gt; 0) { if (direciton == Vector3.zero) { break; } direciton = direciton.normalized; bool hit = Physics.CapsuleCast(Point1, Point2, radius - thickness, direciton, out RaycastHit hitInfo, distance + thickness, layerMask); if (hit) { float actualDis = hitInfo.distance - thickness; transform.position += direciton * actualDis; Vector3 remain = (distance - actualDis) * direciton; Vector3 newMotion = Vector3.ProjectOnPlane(remain, hitInfo.normal); if (newMotion.sqrMagnitude &lt; Mathf.Epsilon) { distance = 0; } else { direciton = newMotion.normalized; distance = newMotion.magnitude; } } else { transform.position += direciton * distance; distance = 0; } } } public void Move(Vector3 motion) { if (motion == Vector3.zero) { return; } Move(motion.normalized, motion.magnitude); }} 这个移动方式的特点是，在玩家碰撞到障碍物时，可以按原有移动向量在障碍物表面上的分量继续移动，不会卡住。 如果不使用 thickness 参数的话，在角色贴合碰撞体的时候，经常会出现检测不到碰撞的情况，也就会造成穿墙。使用 Thickness参数相当于让碰撞体变小一点进行碰撞检测，然后在最终的位移距离上补偿回来。","link":"/2020/06/30/%E5%A4%84%E7%90%86%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8/"},{"title":"搜索引擎于2020年","text":"我：你们觉不觉得这都 2020 年，目前的搜索引擎有点落后了？ 酋：不仅落后，是在倒退。","link":"/2020/07/08/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BA%8E2020%E5%B9%B4/"},{"title":"从第九世代游戏机看未来","text":"PS5 和 XSX 就要到来了，相比于性能，我更在意他们所预示的发展方向。索尼依然在叙事性、独占游戏上下重注；微软则显得更加开放，重心还是在机能和 XGP 上。 我曾经是索粉，但现在是任豚。PS4 上我觉得好玩的游戏并不多，基本上只有血源诅咒。我不爱玩叙事性3A游戏，累，所以我可能不会购买 PS5. 作为开发者来说，把理想设置为制作3A游戏并不适合我。拥抱 PC, 拥抱任天堂，拥抱更多的游戏类型，拥抱更新的游戏方式。","link":"/2020/08/21/%E4%BB%8E%E7%AC%AC%E4%B9%9D%E4%B8%96%E4%BB%A3%E6%B8%B8%E6%88%8F%E6%9C%BA%E7%9C%8B%E6%9C%AA%E6%9D%A5/"},{"title":"使用 Unity 的细枝末节","text":"有很多技术其实都不能称之为技术，比如 Unity 各种 api 的使用方法，但要深入一线开发，又不得不去掌握这些东西。所以干脆就写一篇文章，全部总结一下。 简洁的方式实现 UI 粒子特效 扩展 Button 应该用继承","link":"/2120/09/07/%E4%BD%BF%E7%94%A8-Unity-%E7%9A%84%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82/"},{"title":"简洁的方式实现 UI 粒子特效","text":"最近在使用 Unity URP 时，摸索出了一套简洁的制作 UI 粒子特效的方式。 先创建一个新的 Camera, 将 Render Type 设为 Overlay, Projection 设为 Orthographic, Size 对齐屏幕尺寸, Culling Mask 设为 UI. 为了自适应屏幕大小，写个脚本修改 Camere 的 size: camera.orthographicSize = Screen.height * 0.5f. 还有粒子的 size 也需要修改： 1234567float multiplier = Screen.height / canvasScaler.referenceResolution.y;var particles = GetComponentsInChildren&lt;ParticleSystem&gt;();foreach (var p in particles){ var main = p.main; main.startSizeMultiplier *= multiplier;} 然后给原来 Render Type 为 Base 的 Camera 的 Stack 里加上刚刚新建的 Camera. 然后把 Particle System 做的粒子特效挂到想要挂到的 UI 对象下面，调整 Start Size 到够大，把 Layer 设为 UI. 想要调整粒子和 UI 的前后关系的话，可以调整粒子 Renderer 的 Order in Layer.","link":"/2020/09/03/%E7%AE%80%E6%B4%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0-UI-%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"},{"title":"扩展 Button 应该用继承","text":"以前我扩展 Button 组件的方式是再写一个组件，然后在给 Button 组件加上 Event Trigger 组件去处理事件，比如 PointerUp 等。 后来我发现更好的方式是继承 Button 组件，或者继承 Selectable 组件，然后重载方法。除了做事件响应外，比如做子对象UI的颜色变换等，也非常方便， 比如做需要做一个可拖拽按钮，可以新建一个类 DragableButton : Selectable, IDragHandler . 然后实现 IDragHandler.OnDrag() 方法即可。","link":"/2020/09/07/%E6%89%A9%E5%B1%95-Button-%E5%BA%94%E8%AF%A5%E7%94%A8%E7%BB%A7%E6%89%BF/"},{"title":"Kingdom Rush 独特的兵营","text":"Kingdom Rush 中有一个机制是其他塔防游戏中没有的，就是它的兵营(Barracks). 兵营是以塔的形式出现的，本身没有攻击效果，可以生产3个士兵与敌人搏斗，士兵死后隔一段时间重新生产新的士兵。 Kingdom Rush 中的塔是不能挡路的，也很少有减速效果的手段，但士兵可以拦截敌人，可以说是一种特殊的阻挡敌人的机制。 这个机制有一些特点是： 士兵会找一个一定范围内的敌人，走过去与之搏斗，走路过程中敌人停下来等士兵。 近战敌人不会攻击正在与别人搏斗的士兵，装作没看到继续往前走。 远程敌人会攻击正在与别人搏斗的士兵，经常会有一波远程敌人集火秒士兵的情况。 导致的结果就是它并不是完全把所有敌人挡住，而且挡路效果也不是很稳定，需要经常注意它的状态。","link":"/2020/09/08/Kingdom-Rush-%E7%8B%AC%E7%89%B9%E7%9A%84%E5%85%B5%E8%90%A5/"}],"tags":[{"name":"Unity","slug":"Unity","link":"/tags/Unity/"}],"categories":[{"name":"Nagging","slug":"Nagging","link":"/categories/Nagging/"},{"name":"Developers","slug":"Developers","link":"/categories/Developers/"},{"name":"Develop","slug":"Develop","link":"/categories/Develop/"},{"name":"Design","slug":"Design","link":"/categories/Design/"}]}